code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let
Next Token :  rec, Posbility: 0.3770
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec
Next Token :  , Posbility: 0.3516
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec 
Next Token : f, Posbility: 0.0811
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f
Next Token :  , Posbility: 0.3887
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f 
Next Token : x, Posbility: 0.3594
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x
Next Token :  , Posbility: 0.5508
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x 
Next Token : y, Posbility: 0.9375
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y
Next Token :  , Posbility: 0.9102
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y 
Next Token : z, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z
Next Token :  =, Posbility: 0.8398
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
Next Token : 
, Posbility: 0.7891
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =

Next Token :   , Posbility: 0.8477
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  
Next Token : match, Posbility: 0.5117
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match
Next Token :  , Posbility: 0.9414
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match 
Next Token : x, Posbility: 0.7500
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x
Next Token : ,, Posbility: 0.6289
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x,
Next Token :  , Posbility: 0.9219
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, 
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y
Next Token : ,, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y,
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z
Next Token :  with, Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
Next Token : 
, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with

Next Token :   , Posbility: 0.9336
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  
Next Token : |, Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  |
Next Token :  [],, Posbility: 0.3730
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [],
Next Token :  [],, Posbility: 0.8242
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [],
Next Token :  [], Posbility: 0.9336
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], []
Next Token :  , Posbility: 0.9414
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] ->
Next Token :  [], Posbility: 0.8906
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
Next Token : 
, Posbility: 0.9609
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []

Next Token :   , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  
Next Token : |, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  |
Next Token :  , Posbility: 0.4727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | 
Next Token : x, Posbility: 0.5859
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x
Next Token : ::, Posbility: 0.3926
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::
Next Token : x, Posbility: 0.6328
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::x
Next Token : s, Posbility: 0.8594
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs
Next Token : ,, Posbility: 0.8281
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs,
Next Token :  , Posbility: 0.8906
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, 
Next Token : y, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.6758
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.8398
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 0.7070
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.4863
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 0.6094
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.8242
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.3652
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 0.7383
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 0.7227
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 0.4395
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 0.4629
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.5078
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.7188
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.4668
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9219
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.6367
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.6836
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9180
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9336
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.8750
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 0.9609
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 0.9492
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.6094
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.6172
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 0.9102
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.7344
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 0.9531
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.8984
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.5156
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.7773
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 0.8203
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.8281
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 0.9258
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.8789
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 0.8516
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 0.9180
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.6602
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.7227
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9180
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.8711
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.8945
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9492
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.8047
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.8398
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.8359
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.8984
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9531
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.6719
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.6758
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.8945
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.8281
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.8945
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.8711
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.8945
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9297
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9688
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9102
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9688
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.7227
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.7695
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9180
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.8633
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9336
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9336
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9453
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9492
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.7461
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.8438
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9375
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9141
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9531
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9688
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.8281
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.8789
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9570
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9375
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.8594
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9062
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9688
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9453
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.8867
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9375
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9531
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9180
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9375
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9336
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9453
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9414
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9531
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9688
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9648
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9609
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9531
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9688
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9727
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9766
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9805
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9844
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, 
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::
Next Token : z, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::z
Next Token : s, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs 
Next Token : ->, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs ->
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> 
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::
Next Token : (, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::
Next Token : z, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::z
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs
Next Token : ))), Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
Next Token : 
, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))

Next Token :   , Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  
Next Token : |, Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  |
Next Token :  , Posbility: 0.9922
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | 
Next Token : x, Posbility: 0.9883
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x
Next Token : ::, Posbility: 0.9961
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::
Next Token : x, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::x
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs
Next Token : ,, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs,
Next Token :  , Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, 
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y
Next Token : ::, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::
Next Token : y, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::y
Next Token : s, Posbility: 1.0000
---------------------------
code:
 (* Write a function to interleave 3 lists of the same length into a single flat list. *)
let rec f x y z =
  match x, y, z with
  | [], [], [] -> []
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys, z::zs -> x::(y::(z::(xs::zs)))
  | x::xs, y::ys


<<<<<<<<<<<<< End : Timeout >>>>>>>>>>>>